This technical brief is designed to ensure that Antigravity implements a robust, enterprise-grade data fetching layer that "shakes hands" perfectly with TanStack Table on your frontend.Technical Brief: Standardized Pagination, Sorting, & Filtering1. ObjectivesTo establish a uniform contract for all GET collection endpoints across SchoolHub microservices. This ensures the backend handles heavy lifting (Server-side processing) for thousands of students while providing the frontend with precise metadata for UI rendering.2. The Request Contract (PageOptionsDto)All list requests must accept a standardized set of query parameters. This DTO resides in libs/common to be shared globally.page: The current page number (Default: 1).limit: Number of records per request (Default: 10, Max: 100).order: Sort direction (ASC or DESC).sortField: The database column to sort by (Default: createdAt).search: A string for global keyword searching across multiple columns.3. The Response Contract (PageMetaDto)Every paginated response must return a meta object. This allows TanStack Table to calculate the total number of pages and toggle "Next/Previous" buttons.The logic for pageCount is calculated as follows:$$pageCount = \lceil \frac{itemCount}{limit} \rceil$$Required Fields in meta:itemCount: Total records found after filtering.pageCount: Total number of pages available.hasPreviousPage: Boolean (true if page > 1).hasNextPage: Boolean (true if page < pageCount).4. The Generic Wrapper (PageDto<T>)To maintain Type-Safety and SOLID principles, we use a generic class that wraps the data array and the metadata.data: An array of entities (e.g., StudentEntity[]).meta: The PageMetaDto instance.Implementation Instructions for AntigravityCopy-paste this prompt into your workspace to execute the setup:"Please implement a Standardized Pagination & Sorting system in libs/common following these requirements:Common DTOs: Create an Order enum, a PageOptionsDto (using class-validator and class-transformer), and a PageMetaDto for automatic metadata calculation.Generic PageDto: Create a generic class PageDto<T> to wrap the entity array and its metadata.Global Interceptor Integration: Update the TransformInterceptor to detect if the returned data is an instance of PageDto. If so, render a JSON response where data and meta are top-level fields within the data envelope.QueryBuilder Integration: Provide a reusable logic or base service method that takes a TypeORM SelectQueryBuilder and applies the PageOptionsDto (skip, take, orderBy, and search filters).Example: Apply this to the findAll method in IdentityService to demonstrate fetching a paginated list of Users sorted by Name."